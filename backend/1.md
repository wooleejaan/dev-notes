### 로그인 프로세스 이해

로그인은 회원가입이 선행되어야 함.<br>
브라우저 => 서버로 로그인 요청(id/pw) => 서버가 db에서 찾아보고 해당 정보 존재 확인

- 백엔드 서버 메모리(변수, session이라고 부름)에 저장해둠. => 로그인 uuid(세션id == 토큰id)와 로그인된 이메일 저장 (이 과정을 `인증Authentication`이라고 함)
- 세션id를 브라우저에 전달해줌. 이걸 브라우저는 일반적으로 브라우저 저장공간(변수 말고)에 저장해둠.
- 이후 유저 정보 받아오는 fetchUser 보낼 때, 브라우저에 저장해둔 세션id를 함께 서버에 전달. (이 과정을 `인가Authorization`이라고 함)
- 백엔드 메모리(세션)에 저장해둔 정보와 일치하면 확인.

문제점(사용자 접속량 많아지면 서버 컴퓨터 메모리 용량 부족) => 해결방법 2가지

- 컴퓨터 사양 높이기 (스케일업)
- 컴퓨터 사양을 높이는 대신, 백엔드 컴퓨터 여러 대 배치. (스케일아웃) => 각각 컴퓨터에서 동일한 소스코드 복사해서 yarn start ...

스케일아웃의 문제점(유저가 서버컴퓨터1에서 인증했는데, 서버컴퓨터2에서 인가하려면? => 결과적으로 메모리 세션도 모든 컴퓨터마다 존재해야 함)

- 메모리(세션)을 백엔드 컴퓨터에 두지 말고, db의 세션 테이블에 두는 방식으로 변경 (세션 테이블)
- 백엔드 컴퓨터가 메모리를 운영한다는 것 == 상태 관리 == stateful
- 메모리를 db로 옮기고, 백엔드 서버가 stateless가 되면 스케일아웃을 할 수 있음.

위 해결 방법의 문제점 (트래픽이 결국에는 db로 몰림. 병목현상은 동일) => db를 쪼개는 방법 (파티셔닝 기법)

- 수직 파티셔닝 (좌우로 쪼개는 것 => `정규화`와 무슨 차이? => 정규화는 의미 기준으로 쪼개는 반면, 파티셔닝은 같은 의미더라도 개수가 많으면 쪼갠다. 자주 쓰이는 상태 위주로 쪼갬.)
- 수평 파티셔닝 (수평으로 쪼개되, 쪼개서 다른 db에 저장하는 건 `샤딩`이라고 함)

쪼갠다는 것은? => 서버로 들어온 유저 요청 확인 후, 1-1000이면 db1로 보내고 1001-2000이면 db2로 보내고...<br>
db에서 데이터를 조회한다는 것은? => 하드디스크에서 파일을 찾는 것과 같음.

- ram과 달리, disk에서 찾는 건 느림. cpu/ram/disk로 생각해보면 쉬움.
- 즉, `Disk I/O`가 많아짐. 디스크 조회하고 받아오는 게 많아져서 느려지므로 또 하나의 문제가 됨.

Disk I/O를 어떻게 줄이지? => db 중에서도 disk i/o에 저장 안 하는 방법으로 우회 (`Redis라는 db에 저장 (mysql이 아닌)`)

- Redis는 데이터를 저장하되, `디스크`에 저장하지 않고 `메모리`에 저장함
  - 속도가 빠름. 대신 영구저장 아님(영구저장 옵션은 존재)

=> 세션 테이블을 Redis에 넣는 방식으로 발전하게 됨 (성능 개선)

- 인가를 하기 위해, redis에서 토큰id(세션id) 일치하는지 확인 -> 그다음 db에서 유저 정보 가져오는 프로세스.

또 하나의 문제 => 매 api 요청마다 redis를 가야하면 (쿼리가 2번씩 발생)

=> redis가 아닌 jwt 토큰 방식으로 변경

인증을 위해서 db는 무조건 가야함 (user 테이블의 실제 정보와 비교해야 하므로)

- db에서 확인한 후 => 서버컴퓨터 메모리나 db 테이블에 저장하지 않고, 이메일 같은 정보를 임의의 id로 만듦.
- 만드는 방법? => 객체 만들고, 객체를 변수에 담고 암호화(이후 복호화 가능) => 암호화된 결과를 세션 토큰으로 사용 (세션 토큰을 브라우저에 전달 => 브라우저는 세션 토큰을 쿠키에 저장)
- 브라우저는 매 요청마다 세션 토큰을 서버로 전달 => 서버는 이제 더 이상 redis로 가서 확인하는 과정을 거치지 않고, 그 자리에서 바로 복호화 => 똑같은 결과가 나오면 redis에 가지 않아도 유저 정보 일치한다는 것을 확인 (인가를 위해 쿼리 2번 날릴 필요 없음)
- 여기에서 사용한 토큰이 jwt(Json Web Token) => JSON(JavaScript Object Notation)
