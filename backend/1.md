### 로그인 프로세스 이해

로그인은 회원가입이 선행되어야 함.<br>
브라우저 => 서버로 로그인 요청(id/pw) => 서버가 db에서 찾아보고 해당 정보 존재 확인

- 백엔드 서버 메모리(변수, session이라고 부름)에 저장해둠. => 로그인 uuid(세션id == 토큰id)와 로그인된 이메일 저장 (이 과정을 `인증Authentication`이라고 함)
- 세션id를 브라우저에 전달해줌. 이걸 브라우저는 일반적으로 브라우저 저장공간(변수 말고)에 저장해둠.
- 이후 유저 정보 받아오는 fetchUser 보낼 때, 브라우저에 저장해둔 세션id를 함께 서버에 전달. (이 과정을 `인가Authorization`이라고 함)
- 백엔드 메모리(세션)에 저장해둔 정보와 일치하면 확인.

문제점(사용자 접속량 많아지면 서버 컴퓨터 메모리 용량 부족) => 해결방법 2가지

- 컴퓨터 사양 높이기 (스케일업)
- 컴퓨터 사양을 높이는 대신, 백엔드 컴퓨터 여러 대 배치. (스케일아웃) => 각각 컴퓨터에서 동일한 소스코드 복사해서 yarn start ...

스케일아웃의 문제점(유저가 서버컴퓨터1에서 인증했는데, 서버컴퓨터2에서 인가하려면? => 결과적으로 메모리 세션도 모든 컴퓨터마다 존재해야 함)

- 메모리(세션)을 백엔드 컴퓨터에 두지 말고, db의 세션 테이블에 두는 방식으로 변경 (세션 테이블)
- 백엔드 컴퓨터가 메모리를 운영한다는 것 == 상태 관리 == stateful
- 메모리를 db로 옮기고, 백엔드 서버가 stateless가 되면 스케일아웃을 할 수 있음.

위 해결 방법의 문제점 (트래픽이 결국에는 db로 몰림. 병목현상은 동일) => db를 쪼개는 방법 (파티셔닝 기법)

- 수직 파티셔닝 (좌우로 쪼개는 것 => `정규화`와 무슨 차이? => 정규화는 의미 기준으로 쪼개는 반면, 파티셔닝은 같은 의미더라도 개수가 많으면 쪼갠다. 자주 쓰이는 상태 위주로 쪼갬.)
- 수평 파티셔닝 (수평으로 쪼개되, 쪼개서 다른 db에 저장하는 건 `샤딩`이라고 함)

쪼갠다는 것은? => 서버로 들어온 유저 요청 확인 후, 1-1000이면 db1로 보내고 1001-2000이면 db2로 보내고...<br>
db에서 데이터를 조회한다는 것은? => 하드디스크에서 파일을 찾는 것과 같음.

- ram과 달리, disk에서 찾는 건 느림. cpu/ram/disk로 생각해보면 쉬움.
- 즉, `Disk I/O`가 많아짐. 디스크 조회하고 받아오는 게 많아져서 느려지므로 또 하나의 문제가 됨.

Disk I/O를 어떻게 줄이지? => db 중에서도 disk i/o에 저장 안 하는 방법으로 우회 (`Redis라는 db에 저장 (mysql이 아닌)`)

- Redis는 데이터를 저장하되, `디스크`에 저장하지 않고 `메모리`에 저장함
  - 속도가 빠름. 대신 영구저장 아님(영구저장 옵션은 존재)

=> 세션 테이블을 Redis에 넣는 방식으로 발전하게 됨 (성능 개선)

- 인가를 하기 위해, redis에서 토큰id(세션id) 일치하는지 확인 -> 그다음 db에서 유저 정보 가져오는 프로세스.

또 하나의 문제 => 매 api 요청마다 redis를 가야하면 (쿼리가 2번씩 발생)

=> redis가 아닌 jwt 토큰 방식으로 변경

인증에는 db에 무조건 가야함. user 테이블에 실제 정보랑 비교해야 하니까.

- 가서 확인했으면, 거기서 서버컴퓨터 메모리나 db테이블에 저장해두는 게 아니라, 유저가 보낸 예를 들어 이메일 같은 걸로 임의의 id를 만들어냄.
- 어떻게 만드는지? 일종의 객체를 만들고. 객체를 변수에 담고 암호화를 시킴. 암호환된 결과를 세션 토큰으로 사용하는 거임. 그리고 얘를 브라우저에 넘기는 거임. (브라우저는 이걸 쿠키에 저장함.)
- 참고로, 암호화는 암호화 알고리즘을 사용해서 하는 건데, 암호화를 했으면 당연히 복호화도 가능함.
- 브라우저는 그렇게 전달받은 걸 쿠키에 저장해두고 인가 요청마다 같이 똑같이 전달하는데.
- 그럼 원래라면 서버는 redis에 가서 확인하는 과정을 거쳤어야 했는데, 그 서버에서 바로 그 자리에서 복호화를 해버림. 똑같은 결과가 나왔으면? redis에 안 가도 유저 정보가 일치한다는 걸 알 수 있음.
- 그럼 그 상태로 db 가서 데이터 가져오면 되니까 인가를 위해 쿼리 2번씩 날릴 필요가 없어짐.
- 여기에 사용한 토큰이 jwt 토큰임. Json Web Token의 약자. JSON은 JavaScript Object Notation의 약자.
